\documentclass[a4paper,10pt]{article}


\usepackage{listings}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[german]{babel}
\usepackage{fontenc}
\usepackage{fancyhdr, graphicx}
\usepackage{wasysym}
\usepackage{fullpage}
\usepackage{textcomp}
\usepackage{fancyhdr} %for header/footer

%My Commands
\newcommand{\BN}{\mathbb{B}} %BOOL
\newcommand{\RN}{\mathbb{R}} %Real Number
\newcommand{\NN}{\mathbb{N}} %Natural Number
\newcommand{\QN}{\mathbb{Q}} %Rational Number
\newcommand{\ZN}{\mathbb{Z}} %ganze Zahlen
\newcommand{\CN}{\mathbb{C}}
\newcommand{\Teilt}{\mid} %|
\newcommand{\Teiltn}{\nmid} %kein teiler
\newcommand{\Potp}{\mathcal{P}} %Potenzmenge
\newcommand{\Pota}{\mathcal{A}}
\newcommand{\Potr}{\mathcal{R}}
\newcommand{\Potn}{\mathcal{N}}
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch
\newcommand{\lra}{\leftrightarrow} %Arrows
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}
\newcommand{\Vektor}[1]{\vec{#1}}
\newcommand{\Brace}[1]{\left( #1 \right)} %()
\newcommand{\Bracel}[1]{\left\lbrace #1 \right.} %(
\newcommand{\Bracer}[1]{\right. #1 \right\rbrace} %)
\newcommand{\Brack}[1]{\left\lbrace #1 \right\rbrace} %{}
\newcommand{\Brackl}[1]{\left\lbrace #1 \right.} %{
\newcommand{\Brackr}[1]{\right. #1 \right\rbrace} %}
\newcommand{\Result}[1]{\underline{\underline{#1}}} %Doppelt unterstrichen
\newcommand{\Abs}[1]{\left| #1 \right|} %Absolutbetrag
\newcommand{\Norm}[1]{\Abs{\Abs{ #1 }}} %Norm
\newcommand{\Arrays}[1]{\left(\begin{array}{c}#1\end{array}\right)} %Array mit einer Kolonne ()
\newcommand{\Array}[2]{\left(\begin{array}{#1}#2\end{array}\right)} %Array mit n Kolonnen ()
\newcommand{\Bracka}[2]{\left\lbrace\begin{array}{#1}#2\end{array}\right\rbrace} %Array mit {}
\newcommand{\Brackal}[2]{\left\lbrace\begin{array}{#1} #2 \end{array}\right.} %Array mit {
\newcommand{\Brackar}[2]{\left.\begin{array}{#1} #2 \end{array}\right\rbrace} %Array mit }
\newcommand{\Sumone}[2]{\sum_{#2=1}^{#1}} %Summe von 1
\newcommand{\Sumz}[2]{\sum_{#2=0}^{#1}} %Summe von 0
\newcommand{\Sum}[2]{\sum_{#2}^{#1}} %Allgemeine Summe
\newcommand{\Oneover}[1]{\frac{1}{#1}} %1 \UTF{00FC}ber igendwas
\newcommand{\Tablewt}[3]{\begin{table*}[h]\caption{#1} \begin{tabular}{#2}{#3}\end{tabular}\end{table*}} %Table mit Titel
\newcommand{\Oben}[2]{\overset{#1}{#2}} %etwas \UTF{00FC}ber etwas anderem
\newcommand{\Unten}[2]{\underset{#1}{#2}} %etwas unter etwas anderem
\newcommand{\Bildcap}[2]{\begin{figure}[htb]\centering\includegraphics[width=0.2\textwidth]{#1} \caption{#2}\end{figure}} %Bild mit beschriftung
\newcommand{\Bildjpeg}[1]{\includegraphics[width=0.2\textwidth]{#1.jpeg}} %Bilder jpeg!!
\newcommand{\Bildjpg}[1]{\includegraphics[width=0.2\textwidth]{#1.jpg}} %Bilder jpg!!

%Zeichnung
\usepackage{tikz}
\usepackage[all]{xy}
\usepackage{ucs}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}
\pagestyle{plain}

%Metadata
\title{Algorithmen und Datenstrukturen}
\author{Jan F\"assler}
\date{2. Semester (FS 2012)}
\fancyfoot[C]{Jan F\"assler}

\begin{document}
\maketitle
\newpage
\thispagestyle{fancy} %f\UTF{00FC}r Header

\section{Daten \& Informationenen}

\subsection{Digitaltechnik}
\begin{tabular}{l l l}
	1 & low & 0 bis 0.8V \\
	0 & high & 2.4 bis 5V
\end{tabular} \\ \\
Mit einer Bitfolge der L\"ange n k\"onnen $2^n$ verschiedene Zust\"ande codiert werden.

\subsection{Byte}
\begin{itemize}
	\item geordnete Bitfolge der L\"ange 8 (256 Zust\"ande)
	\item Bits werden mit Indizes von 0 bis 7 nummeriert
	\item LSB (Least Significant Bit)
	\item MSB (Most Significant Bit)
\end{itemize}
\begin{tabular}{l l}
	KiByte & $2^{10}$ Byte \\
	MiByte & $2^{20}$ Byte \\
	GiByte & $2^{30}$ Byte \\
\end{tabular}

\subsection{Daten \& Informationenen}
Bitfolgen sind lediglich Daten und werden nach der Interpretation zu Informationen. \\ \\
Interpretationsarten sind Datentypen
\begin{itemize}
	\item Interpretation als ganze Zahl
	\item Interpretation als Gleitkommazahl
	\item Interpretation als alphanumerisches Zeichen
	\item benutzerdefinierte Interpretation
\end{itemize}

\subsection{Positive Zahlen}
\begin{tabular}{c c c c c c c c}
	MSP & & & & & & & LSB \\
	1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
	$2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$
\end{tabular}
In Java nur char (16 Bit) \\ \\ \\
$1*2^7+1*2^5+1*2^2+1*2^1+1*2^0=128+32+4+2+1=\uuline{167}$

\subsection{Ganze Zahlen (2er - Komplement)}
\begin{tabular}{c c c c c c c c}
	1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
	$2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$
\end{tabular} 
In Java: long (64 Bit), int (32 Bit), short (16 Bit) \& byte (8 Bit) \\ \\ \\
$-1*2^7+1*2^5+1*2^2+1*2^1+1*2^0=-128+32+4+2+1=\uuline{-89}$

\subsection{Zahlendarstellung mit beliebiger Basis}
\begin{description}
	\item[bin\"ar (2)] - Zahlen die mit 0b beginnen
	\item[octal (8)] - Zahlen die mit 0 beginnen
	\item[dezimal (10)] - Zahlen die nicht mit 0 beginnen
	\item[hex (16)] - Zahlen die mit 0x beginnen
\end{description}
Positive Zahlen: $\sum b_i+B^i mit i \in [0,n-1]$ und $b_i$ gleich der Ziffer bei i. \\ \\
Ganze Zahlen: $-b_{n-1}*B^{n-1}+\sum b_i*B^i mit i \in [0,n-2]$ und  $b_i$ Ziffer bei i.

\subsection{Gleitkommazahlen}
Exponentialdarstellung: $(-1)^V * (1+M)*2^E$ \\
\begin{description}
	\item[V] - Vorzeichen (float 1Bit / double 1 Bit)
	\item[M] - normalisierte Mantrisse $(0 \leq M \leq 1)$ (float 23 Bit / double 52Bit)
	\item[E] - Exponent (E+127) (float 8 Bit / double 11 Bit)
\end{description} 
\begin{tabular}{|c|l|l|}
	\hline
	V & Exponent & Mantrisse \\
	\hline
\end{tabular}

\subsubsection{Beispiele}
\begin{description}
	\item[2.5] $=1.25*2^1$
	\item[-0.75] $=\underbrace{1}_{\ominus}\underbrace{01111110}_{-1+127}\underbrace{1000...}_{0.5}=-1.5*2^{-1}$
	\item[0.1] $=\underbrace{0}_{\oplus}\underbrace{11110111}_{-4+127}\underbrace{100\overline{1100}}_{0.6}=1.6*2^{-4}$
\end{description}

\subsubsection{Spezialf\"alle}
\begin{description}
	\item[E=-127 M=0] $\Rightarrow 0$
	\item[E=128 M=0 V=+] $\Rightarrow +\infty$
	\item[E=128 M=0 V=$-$] $\Rightarrow -\infty$
	\item[E=128 M!=0] $\Rightarrow NaN$
\end{description}

\subsubsection{Division mit Null}
\begin{itemize}
	\item float f = 0.0f/0.0f = $NaN$
	\item float f = 7.6f/0.0f = $+\infty$
	\item float f = -3.9f/0.0f = $-\infty$
\end{itemize}

\newpage
\section{Operationen \& Ausdrücke}

\subsection{Auswertungsreihenfolge}
\begin{itemize}
	\item einstellige und mehrstellige Operatoren
		\begin{itemize}
			\item[1.] Teilausdrücke in Klammern
			\item[2.] Ausdrücke mit unären Operatoren (pro Operand von rechts nach links)
			\item[3.] Teilausdrücke mit mehrstelligen Operatoren gemäss Prioritätstabelle
		\end{itemize}
	\item mehrstellige Operatoren gleicher Priorität \\
		bei gleicher Priorität entscheidet die Assoziativität (von links nach rechts oder von rechts nach links)
	\item Bewertungsreihenfolge von Operanden \\
		die Operanden eines Operators werden strikt von links nach rechts ausgewertet
\end{itemize}
\includegraphics[width=150mm]{operatoren_prios.png}

\subsection{Bitoperatoren}
logische oder auch Boolesche Operatore:
\begin{itemize}
	\item Operanden sind von einem ganzzahligen Datentyp
	\item Negation ~a ($\sim 0 \equiv 1$ / $\sim 1\equiv 0$)
	\item AND a \& b
	\item OR a | b
	\item XOR a $\wedge$  b
\end{itemize}
\begin{tabular}{|c|c|c|c|}
	\hline
	a & b & {a \& b} & a | b \\
	\hline
	0 & 0 & 0 & 0 \\
	0 & 1 & 0 & 1 \\
	1 & 0 & 0 & 1 \\
	1 & 1 & 1 & 1 \\
	\hline
\end{tabular}

\subsection{Schiebeoperatoren}
\begin{itemize}
	\item Rechtsschiebe-Operatoren
		\begin{itemize}
			\item vorzeichenbehaftet: $a >> b$
			\item vorzeichenlos: $a >>> b$
		\end{itemize}
	\item Linksschiebe-Operator
		\begin{itemize}
			\item kann Vorzeichen ver\"andern:  $a << b$
		\end{itemize}
\end{itemize}

\subsubsection{1er-Bits zählen}
\begin{lstlisting}
public static int count(int x) {
	final int intSize = 32;  // Anzahl Bits einer Integer-Zahl
	int y = 0;               // output
	for (int i=0; i < intSize; i++) { 
		if (x%2 == 1) y++;
		x >>>= 1;
	}
	return y;
}

\end{lstlisting}

\subsubsection{effizienter Zähler der 1er-Bits}
\begin{lstlisting}
public static int countEfficiently(int x) {
	int iEven, iOdd, d = 1;
	iEven = x & 0x55555555; x >>= d; iOdd = x & 0x55555555; 
	x = iOdd + iEven; d <<= 1 ;
	iEven = x & 0x33333333; x >>= d; iOdd = x & 0x33333333; 
	x = iOdd + iEven; d <<= 1 ;	
	iEven = x & 0x0F0F0F0F; x >>= d; iOdd = x & 0x0F0F0F0F; 
	x = iOdd + iEven; d <<= 1;	
	iEven = x & 0x00FF00FF; x >>= d; iOdd = x & 0x00FF00FF; 
	x = iOdd + iEven; d <<= 1 ;
	iEven = x & 0x0000FFFF; x >>= d; iOdd = x & 0x0000FFFF; 
	x = iOdd + iEven; d <<= 1 ;	
	return x;
}
\end{lstlisting}

\subsubsection{Ganzzahlige Addition}
\begin{lstlisting}
public static int add(int a, int b) {
	int c, r, t; // output r = a + b
	r = a^b; // Addition entspricht fast einer XOR-Operation 
	c = a&b; // Carry-Flags bestimmen
	while (c != 0) { // Carry-Flags hinzuaddieren
		c <<= 1;
		t = r; r ^= c; c &= t;
	}
	return r;
}
\end{lstlisting}

\subsubsection{Ganzzahlige Multiplikation}
\begin{lstlisting}
public static long mult(int a, int b) {
	long y = 0; // output y = a*b
	while (a != 0) {
		if (a%2 == 1) y += b; 
		b <<= 1;
		a >>= 1;
	}
	return y;
}
\end{lstlisting}

\subsection{Logische Operatoren}

\begin{itemize}
	\item logische oder auch Boolesche Operatoren
		\begin{itemize}
			\item Operanden sind vom Datentyp boolean
			\item logische Negation !A
			\item logisches UND A \&\& B  / A \& B \\
				(Bei zwei \& Zeichen wird erst A überprüft und B nur, falls A wahr ist.)
			\item logisches ODER A $||$ B / A $|$ B
		\end{itemize}
	\item Bedingungsoperator: A ? B : C \\
		if (A) then B else C
\end{itemize}

\subsection{Konvertierung von Datentypen}
\begin{itemize}
	\item explizite Typkonvertierung
		\begin{itemize}
			\item Konvertierungen sind möglich:
				\begin{itemize}
					\item zwischen numerischen Datentypen (erweiternd und einschränkend)
					\item zwischen Referenztypen
				\end{itemize}
			\item funktionieren gleich wie implizite, allerdings bestehen mehr Möglichkeiten
			\item cast-Operator: (Typname) Ausdruck
		\end{itemize}
	\item implizite (automatische) Typkonvertierung
		\begin{itemize}
			\item zwischen Operanden von numerischem Typ (nur erweiternd)
			\item zwischen Operanden von Referenztypen
			\item bei Verknüpfungen von String-Objekten mit Operanden anderer Typen
		\end{itemize}
\end{itemize}

\subsubsection{Typkonvertierungen}
\begin{itemize}
	\item erweiternde Umwandlung \\
		Wert ist immer darstellbar \\
		möglicher Verlust an Genauigkeit (z.B. bei Konvertierung von int nach float) \\ \\
		\includegraphics[width=75mm]{erweiternde_typumwandlung.png} \\
		
	\item einschränkende Umwandlung \\
		möglicher Informationsverlust in Grösse, Vorzeichen \& Genauigkeit \\ \\
		\includegraphics[width=75mm]{einschraenkende_typumwandlung.png}
\end{itemize}

\subsubsection{Integer-Erweiterung}
\begin{itemize}
	\item Datentypen byte, short und char werden in Ausdrücken mit unären und binären Operatoren implizit in int konvertiert
		\begin{itemize}
			\item Dimensionsausdruck bei der Erzeugung von Arrays
			\item Indexausdruck in Arrays
			\item Operand der unären Operatoren + und –
			\item Operand des Invertierungsoperators für Bits $\sim$
			\item Operanden der Schiebeoperatoren $>>$, $>>>$ und $<<$
		\end{itemize}
	\item byte, short und char werden somit fast ausschliesslich als Datenfelder für Klassen benutzt
\end{itemize}

\subsubsection{Implizite Konvertierung}
\begin{itemize}
	\item arithmetische Operatoren
		\begin{itemize}
			\item Ziel: gemeinsamer Typ für beide Operanden und somit auch für das Resultat
			\item Konvertierung in höheren Typ gemäss Hierarchie
			\item Beispiele: \\ $c = (5.0/9)*(f – 32)$ \\ $x = 2*3L + 1.1$
		\end{itemize}
	\item Zuweisungsoperatoren
		\begin{itemize}
			\item zulässig sind nur erweiternde Konvertierungen mit der einen Ausnahme, wenn rechts ein konstanter Ausdruck vom Typ int steht, der darstellbar ist
			\item Rückgabewert von Methoden: wie bei Zuweisung
			\item Parameterübergabe bei Methoden: wie Zuweisung aber ohne deren Ausnahme mit dem konstanten Ausdruck
		\end{itemize}
\end{itemize}

\subsubsection{Konvertierungsvorschriften}
\begin{itemize}
	\item erweiternde Konvertierung von vorzeichenbehafteten Integer-Typen \\
		Wert bleibt unverändert
	\item Konvertierung zwischen char und vorzeichenbehafteten Integer-Typen
		\begin{itemize}
			\item char ist vorzeichenlos
			\item bei gleicher Breite: Bitmuster bleibt erhalten
			\item char ist breiter: von links mit Nullen auffüllen und Vorzeichen propagieren
			\item char ist schmaler: kein korrektes Resultat, wenn Wert grösser als $2^16$
		\end{itemize}
	\item Konvertierung von Integer nach Gleitpunkt \\
		nächst höherer oder niedriger darstellbarer Wert
	\item Konvertierung von Gleitpunkt nach Integer
		\begin{itemize}
			\item Nachkommastellen werden abgeschnitten
			\item bei Werten grösser als $2^31 – 1$ ist das Resultat nicht korrekt ($= 2^31 – 1$)
		\end{itemize}
	\item Konvertierung zwischen Gleitpunkt-Typen
		\begin{itemize}
			\item float nach double: Wert bleibt unverändert
			\item double nach float: Wert im zulässigen Wertebereich von float, dann nächst höherer oder niedriger darstellbarer Wert
		\end{itemize}
\end{itemize}

\newpage
\section{Zeichen \& Strings}
\subsection{Wichtige Zeichencodes}

\subsection{Alte Zeichencodes}

\subsection{Unicode}

\subsubsection{UTF-16}

\subsubsection{UTF-8}


\newpage
\section{Suchen}

\subsection{Zahlensuche}
Generell gilt hier: Ordnung reduziert den Suchaufwand!

\subsubsection{Array einf\"ullen}
\begin{lstlisting}
final int n=10000;
int[] array=new int[n];
for(int i=0;i<array.length;i++) {
  array[i] = (int) (Math.random()*Integer.MAX_VALUE);
}
\end{lstlisting}

\subsubsection{Lineare Suche}
\begin{lstlisting}
int i=0;
while(i<array.lenght && array[i]!=x) i++;
boolean gefunden = (i < array.length);
\end{lstlisting}

\subsubsection{Lineare Suche mit W\"achter (Sentinel)}
\begin{lstlisting}
boolean gefunden = false;
int last = (array.length-1);
if (array[last]==x) {
  gefunden=true;
} else {
  int tmp = array[last];
  array[last]=x;
  int i=0;
  while(array[i] != x) i++;
  gefunden = (i < last);
  array[last] = tmp;
}
\end{lstlisting}

\subsubsection{Bin\"are Suche}
\begin{lstlisting}
boolean binarySearch(double[] array, double x) {
  int first=0, last=array.lenght-1, m;
  while(first <= last) {
    m = first + (first - last) / 2;  //schneller (m=(first+last)>>>1)
    if(array[m] == x) return true;
    else if (array[m] < x) first=m+1;
    else last=m-1;
  }
}
\end{lstlisting}

\subsubsection{Analyse}
\begin{tabular}{l | l | c | c | c }
	Typ & Laufzeit & n & 256 & $2^{20}$ \\
	\hline
	Lineare Suche & lineare Laufzeit & n & 256 & $2^{20}$ \\
	Bin\"are Suche & logarithmisch & $[log_{2}(n)]+1$ & 9 & 21
\end{tabular}

\subsection{Textsuche}
\subsubsection{Naive Textsuche}
\begin{tabular}{l c c c c c c c l}
	text: & a & e & e & i & e & i & n & (n Zeichen) \\
	pattern: & e & i & n & & & & & (m Zeichen) \\
	& \lightning & e & i & n \\
	& & \checkmark & \lightning \\
	& & & e & i & n \\
	& & & \checkmark & \checkmark & \lightning \\
	& & & & e & i & n \\
	& & & & \lightning & e & i & n \\
	& & & & & \checkmark & \checkmark & \checkmark \\
\end{tabular} \\ \\
Auswertung: $T(n,m) = m(n-m+1)=m*n-m^2+m$

\subsubsection{Knuth-Morris-Pratt (KMP)}
Als erstes wird beim KMP das zu suchende Pattern untersucht. Das Pattern wird mit sich selber verglichen. Das Ziel ist zu wissen, bei welchem Buchstaben des Patterns man bei einem Missmatch weitermachen soll. \\
Es wird für jedes Teilstück des Patterns das Endstück maximaler Länge gesucht, welches einem Anfangsstück entspricht. Dann wird abgespeichert, wo mit dem Vergleichen fortgefahren werden muss, wenn an dieser Stelle ein Fehler auftritt. \\ \\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline 
	0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
	\hline
	h & a & u & s & h & a & l & t \\
	\hline
	-1 & 0 & 0 & 0 & 0 & 1 & 2 & 0 \\
	\hline
\end{tabular} \\ \\ \\
Die Tabelle Zeigt die Verschiebeinformationen für das Beispiel. Wenn beim Vergleich der Position 5 mit dem Text ein Fehler auftritt, dann muss bei Position 1 (also 1 wieder verglichen werden). Nur für den Anfangsbuchstaben ist der Wert -1. Wenn dieser genommen wird, heisst das, dass das Pattern wieder von vorne verglichen werden muss. \\
Diese Verschiebeinformationen werden zu Beginn der Suche im Text berechnet. Damit muss bei der Suche nie ein Teilstück zweimal durchsucht werden. \\

\Bold{Implementierung:}

\begin{lstlisting}
public class KPM {
    String m_text;
    String m_pattern;
    int[] m_next;

    public KPM(String text, String pattern) {
        m_text = text;
        m_pattern = pattern;
        m_next = new int[pattern.length()];
    }
    
    public void initnext() {
        int i = 0; // wird das Pattern einmal durchlaufen
        int j = -1; // wird zum Vergleich mit dem Anfagsst¸ck verwendet

        m_next[i] = j;
        while (i < m_pattern.length() - 1) {
            if (j < 0 || m_pattern.charAt(i) == m_pattern.charAt(j)) {
                i++;
                j++;
                m_next[i] = j;

            } else {
                j = m_next[j];
            }
        }
    }

    public void search_kmp() {
        int t = 0;
        int p = 0;

        while (t < m_text.length()) {
            // p weiss, mit was im Pattern verglichen werden muss
            // t geht durch den Text
            if ((p < 0) || m_text.charAt(t) == m_pattern.charAt(p)) {
                t++;
                p++;
            } else {
                p = m_next[p];
            }
            if (p == m_pattern.length()) {
                System.out.println("Gefunden, Uebereinstimmung startet bei "
                        + (t - p + 1) + ". Zeichen");
                p = 0;
            }
        }
    }   
    
    public static void main(String[] args) {
         KPM kpm = new KPM("baabcabac", "bac");
         kpm.initnext();
         kpm.search_kmp();
    }
}
\end{lstlisting}

\newpage
\section{Sortieren}
Ein Array a ist sortiert, wenn gilt: \\ \\
$ \forall i \in [0, a.lenght-2] : a[i] relop a[i+1]$ \\
relop: Relation, Bin\"ares Pr\"adikat (typisch: $\leq,\geq,<,>$)

\subsection{\"Uberpr\"ufen, ob das Array sortiert ist}

\begin{lstlisting}
i=0;
while(i<a.lenght-1 && a[i] relop a[i+1] i++;
boolean sortiert = (i==a.length-1);
\end{lstlisting}
Aufwand: linear in der L\"ange des Arrays \\

\subsection{Sortieren durch direktes Ausw\"ahlen (selection sort)}
Das Array wird durch gegangen und nach dem gr\"ossten Element durchsucht. Einmal gefunden, wird es hinten hingesetzt. Danach wird das zweitgr\"osste Element gesucht und vor das gr\"osste Element gestellt. Wenn man dies weiterf\"uhrt w\"achst der sortierte Teil des Arrays kontinuierlich, w\"ahrend der unsortierte Teil kleiner wird.
\begin{lstlisting}
for (int last = a.length-1; last > 0; last--) {
  k=0;
  max = a[k];
  for(int i=1; i <= last; i++) {
    if ( a[i] > max) {
      k=i;
      max=a[k];
    }
  }
}	
\end{lstlisting}
Worst-Case Aufwand: $T(n)=1+2+3+...+(n-3)+(n-2)+(n-1)=\sum^{n-1}_{k=1} k=\frac{n(n-1)}{2}=\frac{n^2-n}{2}\approx\uuline{\frac{n^2}{2}}$

\subsection{Sortierten durch direktes einf\"ugen (insertion sort)}
Das Array wird durch gegangen und jedes Element an der richtigen Stelle, der bereits durch gegangenen Elemente, eingesetzt.
\begin{lstlisting}
for(int first=1; first<a.length;first++) {
  tmp=a[first];
  k=first-1;
  while(k>=0 && a[k]>tmp) {
    a[k+1]=a[k];
    k--;
  }
  a[k+1] = tmp;
}
\end{lstlisting}
Worst-Case Aufwand: $T(n)=1+2+3+...+(n-3)+(n-2)+(n-1)=\sum^{n-1}_{k=1} k=\frac{n(n-1)}{2}=\frac{n^2-n}{2}\approx\uuline{\frac{n^2}{2}}$
Durchschnitt: $T(n)=0.5 + 1 + 1.5 + ... + \frac{(n-3)}{2} + \frac{(n-2)}{2} + \frac{(n-1)}{2}  + \frac{n}{2}=\sum^{n-1}_{i=1} \frac{i}{2}=\frac{1}{2}*\sum^{n-1}_{i=1} i = \frac{1}{2}*(\frac{n^2-n}{2})\approx\uuline{\frac{n^2}{4}}$

\section{Halbdynamischen Datenstrukturen}

\subsection{Das Array}

\begin{itemize}
	\item[Vorteile] 
		\begin{itemize}
			\item hohe Zeiteffizienz, weil auf alle Elemente des Arrays direkt zugegriffen werden kann
			\item hohe Speichereffizienz, wenn die Anzahl der Elemente des Arrays konstant bleibt
		\end{itemize}
	\item[Nachteile] 
		\begin{itemize}
			\item wenn sich die Anzahl Elemente während der Ausführung eines Algorithmus stark ändert, so ist die Speichereffizienz nur bedingt gut
			\item wenn zu Beginn des Algorithmus unklar ist, wie viele Elemente maximal abgespeichert werden müssen, so ist die Datenstruktur Array in Reinform wenig hilfreich.
		\end{itemize}
\end{itemize}

\subsection{Datenstrukturen}

\subsubsection{statische Datenstruktur: Array}
\begin{itemize}
	\item fixer Speicherbedarf, unabhängig von der Anzahl genutzter Elemente im Array
	\item direkter Zugriff auf die Elemente des Arrays
\end{itemize}

\subsubsection{halbdynamische Datenstruktur}
\begin{itemize}
	\item Speicherbedarf passt sich schrittweise der genutzten Anzahl Elemente an und bleibt zwischendrin konstant
	\item direkter Zugriff auf die Elemente
	\item Anpassung des Speicherbedarfs ist zeitaufwändig
\end{itemize}

\subsubsection{dynamische Datenstrukturen: Liste, Stack, Baum usw.}
\begin{itemize}
	\item Speicherbedarf hängt direkt von der genutzten Anzahl Elemente ab
	\item üblich unterstützte Operationen: Suchen, Einfügen, Entfernen
	\item indirekter Zugriff auf die Elemente
\end{itemize}

\subsubsection{Datennutzung \"uber die Zeit}
\includegraphics[width=150mm]{datennutzung_ueber_zeit.png}

\subsection{Das ArrayList}
\begin{itemize}
	\item ArrayList verwendet intern ein Array von Objekten
	\item die Länge des Arrays entspricht der Kapazität
	\item die verwendete Anzahl Elemente ist in size gespeichert
	\item Eine ArrayList startet mit der Gr\"osse 10 wenn nicht's anderes angegeben wurde
	\item Die Kapazit\"at wird erh\"oht, wenn die ArrayList voll ist und ein neues Element hinzugef\"ugt wird.
	\item Die neue Kapazit\"at wir bei der Erh\"ohung wie folgt berechnet: $cap_{new}=cap_{old} * 3 / 2 + 1$
\end{itemize}

\subsubsection{Interner Aufbau (bis Java 1.4.2)}
\begin{itemize}
	\item alle Klassen aus dem Java Collections Framework verwalten intern Referenzen vom Typ Object \\ $\Rightarrow$ maximale Flexibilität
	\item alle Methodenschnittstellen verwenden den Typ Object
	\item da alle Referenztypen zur Klasse Object zuweisungskompatibel sind, bieten die Collections keine Typsicherheit
\end{itemize}

\subsubsection*{Code:}
\begin{itemize}
	\item void add(int index, Object element)
	\item void clear()
	\item boolean contains(Object o)
	\item Object get(int index)
	\item  int indexOf(Object o)
	\item boolean isEmpty()
	\item ListIterator listIterator(int index) • Object remove(int index)
	\item booleanremove(Object o)
	\item Object set(int index, Object element) • int size()
	\item ...
\end{itemize}

\subsubsection{Interner Aufbau (seit Java 5.0)}
\begin{itemize}
	\item alle Collections verwalten intern Referenzen vom Typ <E>, wobei E ein beliebiger Platzhalter (Typ-Parameter) für einen konkreten Referenztyp ist
	\item Collections werden generisch (maximale Flexibilität)
	\item Collections können für alle möglichen Referenztypen verwendet werden, auch
für Object (= früherer interner Aufbau)
\end{itemize}
\end{document}



	
